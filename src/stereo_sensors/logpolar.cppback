/*///////////////////////////////////////////////////////////////////////////////////////
 * //
 * // IMPORTANT: READ BEFORE DOWNLOADING, COPYING, INSTALLING OR USING.
 * //
 * // By downloading, copying, installing or using the software you agree to this license.
 * // If you do not agree to this license, do not download, install,
 * // copy or use the software.
 * //
 * //
 * // License Agreement
 * // For Open Source Computer Vision Library
 * //
 * // Copyright (C) 2012, Willow Garage Inc., all rights reserved.
 * // Third party copyrights are property of their respective owners.
 * //
 * // Redistribution and use in source and binary forms, with or without modification,
 * // are permitted provided that the following conditions are met:
 * //
 * // * Redistribution's of source code must retain the above copyright notice,
 * // this list of conditions and the following disclaimer.
 * //
 * // * Redistribution's in binary form must reproduce the above copyright notice,
 * // this list of conditions and the following disclaimer in the documentation
 * // and/or other materials provided with the distribution.
 * //
 * // * The names of the copyright holders may not be used to endorse or promote products
 * // derived from this software without specific prior written permission.
 * //
 * // This software is provided by the copyright holders and contributors "as is" and
 * // any express or implied warranties, including, but not limited to, the implied
 * // warranties of merchantability and fitness for a particular purpose are disclaimed.
 * // In no event shall the Intel Corporation or contributors be liable for any direct,
 * // indirect, incidental, special, exemplary, or consequential damages
 * // (including, but not limited to, procurement of substitute goods or services;
 * // loss of use, data, or profits; or business interruption) however caused
 * // and on any theory of liability, whether in contract, strict liability,
 * // or tort (including negligence or otherwise) arising in any way out of
 * // the use of this software, even if advised of the possibility of such damage.
 * //
 **/
/*******************************************************************************************
 * The LogPolar Blind Spot Model code has been contributed by Fabio Solari and Manuela Chessa.
 * More details can be found in:
 * M. Chessa, S. P. Sabatini, F. Solari and F. Tatti (2011)
 * A Quantitative Comparison of Speed and Reliability for Log-Polar Mapping Techniques,
 * Computer Vision Systems - 8th International Conference,
 * ICVS 2011, Sophia Antipolis, France, September 20-22, 2011
 * (http://dx.doi.org/10.1007/978-3-642-23968-7_5)
 ********************************************************************************************/
#include "logpolar.hpp"

bool equal(float a, float b, float epsilon)
{
    return abs(a-b) > epsilon;
}

using namespace cv;

LogPolarStereo::LogPolarStereo(int w,
                               int h,
                               Point2i center,
                               int _R,
                               double _ro0,
                               int _interp,
                               int full,
                               int _s,
                               int sp,
                               std::vector<double> & _disparities,
                               float & _sigma,
                               float & _q_like,
                               float & _pole,
                               float & _focal_distance,
                               const unsigned int & _spherical_angle_bins,
                               bool _high_pass
                               ):
    cv::LogPolar_Interp(w, h, center, _R, _ro0, _interp, full, _s, sp),
    disparities(_disparities),
    sigma(_sigma),
    q_like(_q_like),
    pole(_pole),
    focal_distance(_focal_distance),
    spherical_angle_bins(_spherical_angle_bins),
    high_pass(_high_pass)
{

    spherical_top=0;
    spherical_bottom=0;
    spherical_right=0;
    spherical_left=0;


    jc=N/2-1;
    ic=M/2-1;
    spherical_jc=spherical_angle_bins/2-1;
    spherical_ic=spherical_angle_bins/2-1;

    float phi_angle_max_comp=fmin(ic,jc);

    //std::cout << angle_max << std::endl;
    phi_spherical_angle_len=fabs(atan(phi_angle_max_comp/focal_distance)-atan(-phi_angle_max_comp/focal_distance));
    phi_spherical_angle_bins=phi_spherical_angle_len/spherical_angle_step;
    spherical_angle_step=2*CV_PI/spherical_angle_bins;

    phi_spherical_angle_bins=round(phi_spherical_angle_len/spherical_angle_step);

    createCartesianToSphericalWarpMap();
    createSphericalToCartesianWarpMap();
    createCorticalToSphericalWarpMap();
    createSphericalToCorticalWarpMap();

    /////////////////////////////
    // Cortical stereo thingys //
    /////////////////////////////

    createLogpolarWarpMaps(disparities);
    createCartesianLogpolarWarpMaps(disparities);

    float M_=256.0;
    
    occlusion_likelihood=q_like*disparities.size()/(M_-q_like*M_);

    likelihood_images.resize(disparities.size()+1);
    likelihood_images[0]=cv::Mat(S,R, CV_32FC1);
    likelihood_images[0].setTo(cv::Scalar(occlusion_likelihood));
    
    for(int d=1; d<likelihood_images.size(); ++d)
    {
        // Allocate
        likelihood_images[d]=Mat::zeros(S,R, CV_32FC1);
    }

    std::cout << "Done." << std::endl;}

/*if(r==10&&c==10)
        }
    }

    //Eigen::LLT<Eigen::Matrix<double,2,2> > llt_cov=cov_.llt();
    //Eigen::Matrix<double,2,2> chol=llt_cov.matrixL();
    //Eigen::Matrix<double,2,2> A=c*chol;

    //Eigen::Matrix<double,2,2> Y=mean_.replicate(1,2);
    //Eigen::Matrix<double,2,5> sigma_points;
    //sigma_points.block(0,0,2,1) << mean_ ;
    //sigma_points.block(0,1,2,2) << Y+A;
    //sigma_points.block(0,3,2,2) << Y-A;*/

void LogPolarStereo::createLogpolarWarpMaps(const std::vector<double> &disparities)
{
    eta_cortical_warp.resize(disparities.size());
    rho_cortical_warp.resize(disparities.size());
    
    delta_eta_cortical_disparity_map.resize(disparities.size());
    delta_rho_cortical_disparity_map.resize(disparities.size());
    
    for(int d=0; d<disparities.size();++d)
    {
        eta_cortical_warp[d]=Mat::zeros(S,R,CV_32FC1);
        rho_cortical_warp[d]=Mat::zeros(S,R,CV_32FC1);
        
        delta_eta_cortical_disparity_map[d]=Mat::zeros(S,R,CV_32FC1);
        delta_rho_cortical_disparity_map[d]=Mat::zeros(S,R,CV_32FC1);
    }

    int jc=N/2-1, ic=M/2-1;
    for(int s=0; s<S; ++s)
    {
        for(int r=0; r<R; ++r)
        {
            // Get x and y for each logpolar
            double y=(float)(ro0*pow(a,r)*sin(s/q)+jc);
            double x=(float)(ro0*pow(a,r)*cos(s/q)+ic);
            
            for(int d=0; d<disparities.size(); ++d)
            {
                double dx=disparities[d];
                double x_final=x+dx; // Check the sign...
                double y_final=y;
                // get eta, rho for each x disparity
                double eta;
                if(x_final>=ic)
                    eta=atan((double)(y_final-jc)/(double)(x_final-ic));
                else
                    eta=atan((double)(y_final-jc)/(double)(x_final-ic))+CV_PI;
                if(eta<0)
                    eta+=2*CV_PI;
                eta_cortical_warp[d].at<float>(s,r)=(float)(q*eta);
                double ro2=(y_final-jc)*(y_final-jc)+(x_final-ic)*(x_final-ic);
                rho_cortical_warp[d].at<float>(s,r)=(float)(0.5*log(ro2/(ro0*ro0))/log(a));
                
                delta_eta_cortical_disparity_map[d].at<float>(s,r)=eta_cortical_warp[d].at<float>(s,r)-s;
                delta_rho_cortical_disparity_map[d].at<float>(s,r)=rho_cortical_warp[d].at<float>(s,r)-r;
            }
        }
    }
    
    return;
}

void LogPolarStereo::createCartesianLogpolarWarpMaps(const std::vector<double> &disparities)
{
    x_foveal_to_cortical_warp.resize(disparities.size());
    y_foveal_to_cortical_warp.resize(disparities.size());
    
    for(int d=0; d<disparities.size();++d)
    {
        x_foveal_to_cortical_warp[d]=Mat::zeros(S,R,CV_32FC1);
        y_foveal_to_cortical_warp[d]=Mat::zeros(S,R,CV_32FC1);
    }
    
    int jc=N/2-1, ic=M/2-1;
    
    // cartesian to cortical map
    for(int d=0; d<disparities.size(); ++d)
    {
        double dx=disparities[d];
        
        for(int v=0; v<S; v++)
        {
            for(int u=0; u<R; u++)
            {
                x_foveal_to_cortical_warp[d].at<float>(v,u)=(float)(ro0*pow(a,u)*cos(v/q)+ic+dx);
                y_foveal_to_cortical_warp[d].at<float>(v,u)=(float)(ro0*pow(a,u)*sin(v/q)+jc);
            }
        }
    }
    
    return;
}

// Both source and destiny in LogPolar coordinates
void LogPolarStereo::warpLogPolar(const Mat &source, Mat & destiny, const int &disparity_index)
{
    // remap image according to disparity index
    destiny=Mat(S,R,CV_8UC1,Scalar(0));
    remap(source, destiny, rho_cortical_warp[disparity_index],eta_cortical_warp[disparity_index],interp);
}

// Source cartesian, destiny logpolar
void LogPolarStereo::warpCartesianLogPolar(const Mat &source, Mat & destiny, const int &disparity_index)
{
    // remap image according to disparity index
    destiny=Mat(S,R,CV_8UC1,Scalar(0));
    Mat source_border;
    copyMakeBorder(source,source_border,top,bottom,left,right,BORDER_CONSTANT,Scalar(0));
    remap(source_border, destiny, x_foveal_to_cortical_warp[disparity_index], y_foveal_to_cortical_warp[disparity_index],interp);
}







// ATTENTION: sources are logpolar
Mat LogPolarStereo::computeDisparityMap(const Mat &source_left, const Mat &source_right)
{
    ////////////////////////////////////////
    // Compute cortical likelihood images //
    ////////////////////////////////////////

    likelihood_images[0].setTo(cv::Scalar(occlusion_likelihood));
    //std::cout << "likelihood_images[0]:" << likelihood_images[0].at<float>(0,0) << std::endl;
    //std::cout << "occlusion_likelihood:" << occlusion_likelihood << std::endl;

    // Compute likelihood image
    /*for(int s=0; s<S; ++s)
    {
        for(int r=0;r<R; ++r)
        {
            likelihood_images[0].at<float>(s,r).setTo(cv::Scalar(occlusion_likelihood));
        }
    }*/


    for(int d=1; d<likelihood_images.size(); ++d)
    {
        // Reset
        likelihood_images[d].setTo(cv::Scalar(0));

        // remap image according to disparity index
        Mat right_image_transf=Mat::zeros(S,R,CV_8UC1);
        warpLogPolar(source_right,right_image_transf ,d-1);

        // subtract one image from the other
        Mat disparity_map(S,R,CV_32FC1);
        Mat left_image_double;
        Mat right_image_transf_double;
        source_left.convertTo(left_image_double, CV_32FC1);
        right_image_transf.convertTo(right_image_transf_double, CV_32FC1);

        disparity_map=left_image_double-right_image_transf_double;

        // Compute likelihood image
        for(int s=0; s<S; ++s)
        {
            for(int r=0;r<R; ++r)
            {
                //float pdf_gaussian = ( 1.0 / ( sigma * sqrt(2*M_PI) ) ) * exp( -0.5 * pow( (disparity_map.at<float>(s,r))/sigma, 2.0 ) );
                float pdf_gaussian = ( 1.0 / ( sigma * sqrt(2*M_PI) ) ) * exp( -0.5 * pow( (disparity_map.at<float>(s,r))/sigma, 2.0 ) );
                //float disparity_value=disparity_map.at< cv::Vec<float,disparities.size()> >(i,j)[d];

                likelihood_images[d].at<float>(s,r)=pdf_gaussian;
            }
        }
    }

    //////////////////////////////////////
    // Apply first order spatial filter //
    //////////////////////////////////////

    // Compute facilitated likelihood images
    for(int d=0; d < likelihood_images.size(); ++d)
    {
        Mat out;
        PolarFiltFilt2(likelihood_images[d], out, pole, 2, 2);
        likelihood_images[d]=out;
    }

    ///////////////////////////////////////////////////
    // Apply high pass filter on disparity dimension //
    //////////////////////////////////////////////////

    if(high_pass)
    {
        std::cout << "HIGH PASS FILTER!!" << std::endl;
        disparityFilter(likelihood_images);
    }

    ///////////////
    // Normalize //
    ///////////////

    /*for(int s=0; s<S; ++s)
    {
        for(int r=0;r<R; ++r)
        {
            float sum=0.0;

            for(int d=0; d < likelihood_images.size(); ++d)
            {
                sum+=likelihood_images[d].at<float>(s,r);
            }
            
            //std::cout << "sum before:" << sum << " occ like:" << occlusion_likelihood<< std::endl;
            float sum_after=0.0;
            for(int d=0; d < likelihood_images.size(); ++d)
            {
                likelihood_images[d].at<float>(s,r)/=sum;
                //sum_after+=likelihood_images[d].at<float>(s,r);
            }
            //std::cout << "sum after:" << sum_after << std::endl;
        }
    }//*/
    //std::cout << "likelihood_images[0]:"<< likelihood_images[0].at<float>(0,0) << std::endl;


    //////////////////////////////////////////////////////
    // Compute cortical disparity activation images map //
    //////////////////////////////////////////////////////

    Mat disparity_map=Mat::zeros(S,R,CV_32FC1);

    for(int s=0; s<S;++s)
    {
        for(int r=0;r<R;++r)
        {
            // Get disparity with maximum likelihood for pixel i,j

            //Start with occlusion probability
            float max_likelihood=likelihood_images[0].at<float>(s,r);
            //std::cout << "max likelihood occ init: "<< max_likelihood<< std::endl;
            disparity_map.at<float>(s,r)=std::numeric_limits<float>::max();
            //disparity_map.at<float>(s,r)=0.0;

            for(int d=1; d<likelihood_images.size(); ++d)
            {
                if((float)likelihood_images[d].at<float>(s,r)>max_likelihood)
                {
                    max_likelihood=(float)likelihood_images[d].at<float>(s,r);
                    disparity_map.at<float>(s,r)=disparities[d-1];
                }
            }

            //std::cout << "max likelihood occ end: "<< max_likelihood<< std::endl;

        }
    }

    // Get minimum in disparity map
    float minimum=std::numeric_limits<float>::max();

    for(int s=0; s<S;++s)
    {
        for(int r=0;r<R;++r)
        {
            if(disparity_map.at<float>(s,r)<minimum)
                minimum=disparity_map.at<float>(s,r);
        }
    }

    float epsilon=0.1;

    // Replace occluded values by minimum
    for(int s=0; s<S;++s)
    {
        for(int r=0;r<R;++r)
        {
            if(equal((float)disparity_map.at<float>(s,r), std::numeric_limits<float>::max(), epsilon))
            {
                //std::cout << "disparity_map.at<float>(s,r):"<< disparity_map.at<float>(s,r) << " std::numeric_limits<float>::max():" << std::numeric_limits<float>::max()<<"ABS:"<< abs(disparity_map.at<float>(s,r)-std::numeric_limits<float>::max())<< std::endl;
                disparity_map.at<float>(s,r)=minimum-1.0;
            }
        }
    }

    // Subtract minimum from disparity map
    for(int s=0; s<S;++s)
    {
        for(int r=0;r<R;++r)
        {
            disparity_map.at<float>(s,r)-=minimum;
        }
    }


    return disparity_map;
}

std::vector<Mat> LogPolarStereo::getLogPolarEtaWarpMaps()
{
    return eta_cortical_warp;

}

std::vector<Mat> LogPolarStereo::getLogPolarRhoWarpMaps()
{
    return rho_cortical_warp;

}

std::vector<Mat> LogPolarStereo::getDeltaLogPolarEtaWarpMaps()
{
    return delta_eta_cortical_disparity_map;
}

std::vector<Mat> LogPolarStereo::getDeltaLogPolarRhoWarpMaps()
{
    return delta_rho_cortical_disparity_map;
}

LogPolarStereo::~LogPolarStereo()
{
}

// Log polar!!
void LogPolarStereo::PolarFiltFilt2(const Mat &source, Mat &output, float pole, int edge, int wrap)
{
    float a = pole;
    float b = 1-pole;
    float state;

    ///////////////////////
    // Filter per column //
    ///////////////////////

    // Wrap border to avoid angular discontinuities
    Mat source_border;
    copyMakeBorder(source, source_border, wrap, wrap, 0, 0, BORDER_WRAP, Scalar(0));

    for(int u=0; u<R; ++u)
    {
        //forward filtering
        state = source_border.at<float>(0,u);
        for(int v=0; v<S+2*wrap; ++v)
        {
            state=b*source_border.at<float>(v,u)+a*state;
            source_border.at<float>(v,u) = state;
        }

        //backward filtering
        state = source_border.at<float>(S-1+2*wrap,u);
        for(int v = S-1+2*wrap; v >= 0; --v)
        {
            state=b*source_border.at<float>(v,u)+a*state;
            source_border.at<float>(v,u) = state;
        }
    }

    Rect lines_roi = Rect(0, wrap, source.cols, source.rows);
    Mat lines_filtered = source_border(lines_roi);

    /////////////////////
    // Filter per line //
    /////////////////////

    // Wrap border to avoid angular discontinuities
    Mat source_border_cols;
    copyMakeBorder(lines_filtered, source_border_cols, 0, 0, edge, edge, BORDER_REFLECT, Scalar(0));
    for(int v=0; v<S; ++v)
    {
        //forward filtering
        state = source_border_cols.at<float>(v,0);
        for(int u=0; u<R+2*edge; ++u)
        {
            state=b*source_border_cols.at<float>(v,u)+a*state;
            source_border_cols.at<float>(v,u) = state;
        }

        //backward filtering
        state = source_border_cols.at<float>(v,R-1+2*edge);
        for(int u = R-1+2*edge; u >= 0; --u)
        {
            state=b*source_border_cols.at<float>(v,u)+a*state;
            source_border_cols.at<float>(v,u) = state;
        }
    }

    Rect cols_roi = Rect(edge, 0, source.cols, source.rows);
    Mat cols_filtered = source_border_cols(cols_roi);

    output=cols_filtered;

    return;

}

void LogPolarStereo::disparityFilter(std::vector<Mat> & disp)
{

    // Wrap border to avoid angular discontinuities
    std::vector<float> kernel;
    kernel.push_back( -1.0);
    kernel.push_back( -1.0);
    kernel.push_back( 4.0);
    kernel.push_back( -1.0);
    kernel.push_back( -1.0);


    std::vector<float> gaussian_kernel;
    gaussian_kernel.push_back(0.071303);
    gaussian_kernel.push_back(0.131514);
    gaussian_kernel.push_back(0.189879);
    gaussian_kernel.push_back(0.214607);
    gaussian_kernel.push_back(0.189879);
    gaussian_kernel.push_back(0.131514);
    gaussian_kernel.push_back(0.071303);

    ////////////////////
    // low pass first //
    ////////////////////

    std::vector<Mat> disp_back(disp);

    int border=3;
    for(int v=0; v<S; ++v)
    {
        for(int u=0; u<R; ++u)
        {
            // ACCOUNT TO BORDER
            for (int d = border; d < disp.size()-border; ++d)
            {
                disp_back[d].at<float>(v,u)=gaussian_kernel[0]*disp_back[d-3].at<float>(v,u)+
                        gaussian_kernel[1]*disp_back[d-2].at<float>(v,u)+
                        gaussian_kernel[2]*disp_back[d-1].at<float>(v,u)+
                        gaussian_kernel[3]*disp_back[d].at<float>(v,u)+
                        gaussian_kernel[4]*disp_back[d+1]  .at<float>(v,u)+
                        gaussian_kernel[5]*disp_back[d+2].at<float>(v,u)+
                        gaussian_kernel[6]*disp_back[d+3].at<float>(v,u);

            }
        }
    }

    ////////////////////
    // high pass then //
    ////////////////////

    //int border=2;
    for(int v=0; v<S; ++v)
    {
        for(int u=0; u<R; ++u)
        {
            // ACCOUNT TO BORDER
            for (int d = border; d < disp.size()-border; ++d)
            {
                disp[d].at<float>(v,u)=kernel[0]*disp_back[d-2].at<float>(v,u)+
                        kernel[1]*disp_back[d-1].at<float>(v,u)+
                        kernel[2]*disp_back[d]  .at<float>(v,u)+
                        kernel[3]*disp_back[d+1].at<float>(v,u)+
                        kernel[4]*disp_back[d+2].at<float>(v,u);
            }
        }
    }

    return;
}

//////////////////////////////
// CARTESIAN SPHERICAL MAPS //
//////////////////////////////


void LogPolarStereo::createCartesianToSphericalWarpMap()
{

    x_cartesian_to_spherical_warp = Mat::zeros(phi_spherical_angle_bins,spherical_angle_bins, CV_32FC1);
    y_cartesian_to_spherical_warp = Mat::zeros(phi_spherical_angle_bins,spherical_angle_bins,CV_32FC1);
    //float r=focal_distance;
    for(int phi_index=0; phi_index<phi_spherical_angle_bins; ++phi_index) //elevation y
    {
        float phi=phi_index*spherical_angle_step - phi_spherical_angle_len/2.0;
        //float j=tan(phi)*focal_distance+spherical_jc;
        float r=focal_distance/cos(phi);
        for(int theta_index=0; theta_index<spherical_angle_bins; ++theta_index) // azimuthal
        {
            float theta=theta_index*spherical_angle_step - CV_PI;
            float i=r*cos(theta)*sin(phi)+ic;
            float j=r*sin(theta)*sin(phi)+jc;
            //std::cout << "phi: "<<phi << " theta:" <<theta<<"i: "<<i << " j: " <<j << std::endl;
            x_cartesian_to_spherical_warp.at<float>(phi_index,theta_index)=i;
            y_cartesian_to_spherical_warp.at<float>(phi_index,theta_index)=j;
        }

    }

    //exit(-1);
}

void LogPolarStereo::createSphericalToCartesianWarpMap()
{
    theta_spherical_to_cartesian_warp = Mat::zeros(N,M,CV_32FC1);
    phi_spherical_to_cartesian_warp = Mat::zeros(N,M,CV_32FC1);

    for(int j=0; j<N; ++j)
    {
        for(int i=0; i<M; ++i)
        {

            float r=sqrt(pow(i-ic,2)+pow(j-jc,2)+pow(focal_distance,2));
            float theta=atan2(j-jc,i-ic);
            float phi=acos(focal_distance/r);

            float theta_bin=(theta+CV_PI)/spherical_angle_step;
            float phi_bin=(phi+phi_spherical_angle_len/2.0)/spherical_angle_step;

            phi_spherical_to_cartesian_warp.at<float>(j,i)=phi_bin;
            theta_spherical_to_cartesian_warp.at<float>(j,i)=theta_bin;
        }
    }
}

const Mat LogPolarStereo::cartesianToSpherical(const Mat &source)
{
    Mat out(phi_spherical_angle_bins, spherical_angle_bins,CV_8UC1,Scalar(0));
    remap(source,out,x_cartesian_to_spherical_warp,y_cartesian_to_spherical_warp,interp);
    return out;
}

const Mat LogPolarStereo::sphericalToCartesian(const Mat &source)
{
    Mat out(N,M,CV_8UC1,Scalar(0));
    remap(source,out,theta_spherical_to_cartesian_warp,phi_spherical_to_cartesian_warp,interp);
    return out;
}



/////////////////////////////
// CORTICAL SPHERICAL MAPS //
/////////////////////////////

void LogPolarStereo::createCorticalToSphericalWarpMap()
{
    rho_cortical_to_spherical_warp = Mat::zeros(phi_spherical_angle_bins, spherical_angle_bins,CV_32FC1);
    eta_cortical_to_spherical_warp = Mat::zeros(phi_spherical_angle_bins, spherical_angle_bins,CV_32FC1);
    for(int phi_index=0; phi_index<phi_spherical_angle_bins; ++phi_index) //elevation y
    {
        float phi=phi_index*spherical_angle_step - phi_spherical_angle_len/2.0;
        //float j=tan(phi)*focal_distance+spherical_jc;
        float r=focal_distance/cos(phi);
        for(int theta_index=0; theta_index<spherical_angle_bins; ++theta_index) // azimuthal
        {
            float theta=theta_index*spherical_angle_step - CV_PI;
            //float i=tan(theta)*focal_distance+spherical_ic;
            float i=sqrt((pow(r,2)-pow(focal_distance,2))/(1+pow(tan(theta),2)));
            float j=tan(theta)*i;

            double eta;
            if(i>=spherical_ic)
                eta=atan((double)(j-spherical_jc)/(double)(i-spherical_ic));
            else
                eta=atan((double)(j-spherical_jc)/(double)(i-spherical_ic))+CV_PI;

            if(eta<0)
                eta+=2*CV_PI;

            double ro2=(j-spherical_jc)*(j-spherical_jc)+(i-spherical_ic)*(i-spherical_ic);

            rho_cortical_to_spherical_warp.at<float>(phi_index,theta_index)=(float)(0.5*log(ro2/(ro0*ro0))/log(a));
            eta_cortical_to_spherical_warp.at<float>(phi_index,theta_index)=(float)(q*eta); // elevation
        }
    }
}

void LogPolarStereo::createSphericalToCorticalWarpMap()
{
    phi_spherical_to_cortical_warp = Mat::zeros(S,R,CV_32FC1);
    theta_spherical_to_cortical_warp = Mat::zeros(S,R,CV_32FC1);

    float z=focal_distance;

    for(int v=0; v<S; v++)
    {
        for(int u=0; u<R; u++)
        {
            float i=ro0*pow(a,u)*cos(v/q)+ic;
            float j=ro0*pow(a,u)*sin(v/q)+jc;

            float r=sqrt(pow(i,2)+pow(j,2)+pow(z,2));
            float theta=atan2(j,i);
            float phi=acos(z/r);

            theta_spherical_to_cortical_warp.at<float>(v,u)=(float)(0.5*log(theta/(ro0*ro0))/log(a)); // azimuthal
            phi_spherical_to_cortical_warp.at<float>(v,u)  =(float)(0.5*log(phi/  (ro0*ro0))/log(a));;   // elevation
        }
    }

}


const Mat LogPolarStereo::corticalToSpherical(const Mat &source)
{
    Mat out(spherical_angle_bins, spherical_angle_bins,CV_8UC1,Scalar(0));

    Mat source_border;

    if (interp==INTER_NEAREST || interp==INTER_LINEAR){
        copyMakeBorder(source,source_border,0,1,0,0,BORDER_CONSTANT,Scalar(0));
        Mat rowS0 = source_border.row(S);
        source_border.row(0).copyTo(rowS0);
    } else if (interp==INTER_CUBIC){
        copyMakeBorder(source,source_border,0,2,0,0,BORDER_CONSTANT,Scalar(0));
        Mat rowS0 = source_border.row(S);
        Mat rowS1 = source_border.row(S+1);
        source_border.row(0).copyTo(rowS0);
        source_border.row(1).copyTo(rowS1);
    } else if (interp==INTER_LANCZOS4){
        copyMakeBorder(source,source_border,0,4,0,0,BORDER_CONSTANT,Scalar(0));
        Mat rowS0 = source_border.row(S);
        Mat rowS1 = source_border.row(S+1);
        Mat rowS2 = source_border.row(S+2);
        Mat rowS3 = source_border.row(S+3);
        source_border.row(0).copyTo(rowS0);
        source_border.row(1).copyTo(rowS1);
        source_border.row(2).copyTo(rowS2);
        source_border.row(3).copyTo(rowS3);
    }
    remap(source_border,out,rho_cortical_to_spherical_warp,eta_cortical_to_spherical_warp,interp);

    Mat out_cropped=out(Range(spherical_top,spherical_angle_bins-1-spherical_bottom),Range(spherical_left,spherical_angle_bins-1-spherical_right));

    return out_cropped;
}

const Mat LogPolarStereo::sphericalToCortical(const Mat &source)
{
    Mat out(S,R,CV_8UC1,Scalar(0));
    remap(source,out,theta_spherical_to_cortical_warp,phi_spherical_to_cortical_warp,interp);
    return out;
}
